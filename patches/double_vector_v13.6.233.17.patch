diff --git a/src/base/numbers/double.h b/src/base/numbers/double.h
index 0de0aad0847..1301c70606c 100644
--- a/src/base/numbers/double.h
+++ b/src/base/numbers/double.h
@@ -14,11 +14,11 @@ namespace v8 {
 namespace base {
 
 // We assume that doubles and uint64_t have the same endianness.
-inline constexpr uint64_t double_to_uint64(double d) {
-  return std::bit_cast<uint64_t>(d);
+inline uint64_t double_to_uint64(double d) {
+  return v8::base::bit_cast<uint64_t>(d);
 }
-inline constexpr double uint64_to_double(uint64_t d64) {
-  return std::bit_cast<double>(d64);
+inline double uint64_to_double(uint64_t d64) {
+  return v8::base::bit_cast<double>(d64);
 }
 
 // Helper functions for doubles.
@@ -33,7 +33,7 @@ class Double {
   static constexpr int kSignificandSize = 53;
 
   constexpr Double() : d64_(0) {}
-  constexpr explicit Double(double d) : d64_(double_to_uint64(d)) {}
+  explicit Double(double d) : d64_(double_to_uint64(d)) {}
   constexpr explicit Double(uint64_t d64) : d64_(d64) {}
   constexpr explicit Double(DiyFp diy_fp) : d64_(DiyFpToUint64(diy_fp)) {}
 
@@ -155,7 +155,7 @@ class Double {
     *out_m_minus = m_minus;
   }
 
-  constexpr double value() const { return uint64_to_double(d64_); }
+  double value() const { return uint64_to_double(d64_); }
 
   // Returns the significand size for a given order of magnitude.
   // If v = f*2^e with 2^p-1 <= f <= 2^p then p+e is v's order of magnitude.
diff --git a/src/base/vector.h b/src/base/vector.h
index fa2583efb5c..7ac0fd41df0 100644
--- a/src/base/vector.h
+++ b/src/base/vector.h
@@ -293,7 +293,7 @@ class OwnedVector {
   // Elements in the new vector are default-initialized.
   static OwnedVector<T> NewForOverwrite(size_t size) {
     if (size == 0) return {};
-    return OwnedVector<T>(std::make_unique_for_overwrite<T[]>(size), size);
+    return OwnedVector<T>(std::make_unique<T[]>(size), size);
   }
 
   // Allocates a new vector containing the specified collection of values.
